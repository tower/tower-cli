/*
 * Tower API
 *
 * REST API to interact with Tower Services.
 *
 * The version of the OpenAPI document: v0.3.2
 * Contact: hello@tower.dev
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`accept_invitation`]
#[derive(Clone, Debug)]
pub struct AcceptInvitationParams {
    pub accept_invitation_params: models::AcceptInvitationParams
}

/// struct for passing parameters to the method [`cancel_run`]
#[derive(Clone, Debug)]
pub struct CancelRunParams {
    /// The name of the app to fetch runs for.
    pub name: String,
    /// The number of the run to fetch.
    pub seq: i64
}

/// struct for passing parameters to the method [`claim_device_login_ticket`]
#[derive(Clone, Debug)]
pub struct ClaimDeviceLoginTicketParams {
    pub claim_device_login_ticket_params: models::ClaimDeviceLoginTicketParams
}

/// struct for passing parameters to the method [`create_account`]
#[derive(Clone, Debug)]
pub struct CreateAccountParams {
    pub create_account_params: models::CreateAccountParams
}

/// struct for passing parameters to the method [`create_api_key`]
#[derive(Clone, Debug)]
pub struct CreateApiKeyParams {
    pub create_api_key_params: models::CreateApiKeyParams
}

/// struct for passing parameters to the method [`create_apps`]
#[derive(Clone, Debug)]
pub struct CreateAppsParams {
    pub create_app_params: models::CreateAppParams
}

/// struct for passing parameters to the method [`create_secret`]
#[derive(Clone, Debug)]
pub struct CreateSecretParams {
    pub create_secret_params: models::CreateSecretParams
}

/// struct for passing parameters to the method [`create_session`]
#[derive(Clone, Debug)]
pub struct CreateSessionParams {
    pub create_session_params: models::CreateSessionParams
}

/// struct for passing parameters to the method [`create_team`]
#[derive(Clone, Debug)]
pub struct CreateTeamParams {
    pub create_team_params: models::CreateTeamParams
}

/// struct for passing parameters to the method [`delete_api_key`]
#[derive(Clone, Debug)]
pub struct DeleteApiKeyParams {
    pub delete_api_key_params: models::DeleteApiKeyParams
}

/// struct for passing parameters to the method [`delete_app`]
#[derive(Clone, Debug)]
pub struct DeleteAppParams {
    /// The name of the app to delete.
    pub name: String
}

/// struct for passing parameters to the method [`delete_secret`]
#[derive(Clone, Debug)]
pub struct DeleteSecretParams {
    /// The name of the secret to delete.
    pub name: String,
    /// The environment of the secret to delete.
    pub environment: Option<String>
}

/// struct for passing parameters to the method [`delete_team`]
#[derive(Clone, Debug)]
pub struct DeleteTeamParams {
    pub delete_team_params: models::DeleteTeamParams
}

/// struct for passing parameters to the method [`delete_team_invitation`]
#[derive(Clone, Debug)]
pub struct DeleteTeamInvitationParams {
    /// The slug of the team to remove someone from
    pub slug: String,
    pub delete_team_invitation_params: models::DeleteTeamInvitationParams
}

/// struct for passing parameters to the method [`deploy_app`]
#[derive(Clone, Debug)]
pub struct DeployAppParams {
    /// The name of the app to deploy.
    pub name: String,
    /// The encoding of the content.
    pub content_encoding: Option<String>
}

/// struct for passing parameters to the method [`describe_app`]
#[derive(Clone, Debug)]
pub struct DescribeAppParams {
    /// The name of the app to fetch.
    pub name: String,
    /// The number of recent runs to fetch for the app.
    pub runs: Option<i64>
}

/// struct for passing parameters to the method [`describe_app_version`]
#[derive(Clone, Debug)]
pub struct DescribeAppVersionParams {
    /// The name of the app to get the version for.
    pub name: String,
    /// The version string to get the version for.
    pub num: String
}

/// struct for passing parameters to the method [`describe_device_login_session`]
#[derive(Clone, Debug)]
pub struct DescribeDeviceLoginSessionParams {
    /// The device code to check.
    pub device_code: String
}

/// struct for passing parameters to the method [`describe_run`]
#[derive(Clone, Debug)]
pub struct DescribeRunParams {
    /// The name of the app to fetch runs for.
    pub name: String,
    /// The number of the run to fetch.
    pub seq: i64
}

/// struct for passing parameters to the method [`describe_secrets_key`]
#[derive(Clone, Debug)]
pub struct DescribeSecretsKeyParams {
    /// The format to return the key in. Options are 'pkcs1' and 'spki'.
    pub format: Option<String>
}

/// struct for passing parameters to the method [`export_secrets`]
#[derive(Clone, Debug)]
pub struct ExportSecretsParams {
    pub export_secrets_params: models::ExportSecretsParams,
    /// The environment to filter by.
    pub environment: Option<String>,
    /// Whether to fetch all secrets or only the ones that are not marked as deleted.
    pub all: Option<bool>,
    /// The page number to fetch.
    pub page: Option<i64>,
    /// The number of records to fetch on each page.
    pub page_size: Option<i64>
}

/// struct for passing parameters to the method [`generate_run_statistics`]
#[derive(Clone, Debug)]
pub struct GenerateRunStatisticsParams {
    /// Time period for statistics (24h, 7d, 30d)
    pub period: Option<String>
}

/// struct for passing parameters to the method [`get_app_run_logs`]
#[derive(Clone, Debug)]
pub struct GetAppRunLogsParams {
    /// The name of the app to get logs for.
    pub name: String,
    /// The sequence number of the run to get logs for.
    pub seq: i64
}

/// struct for passing parameters to the method [`invite_team_member`]
#[derive(Clone, Debug)]
pub struct InviteTeamMemberParams {
    /// The slug of the team to invite someone to
    pub slug: String,
    pub invite_team_member_params: models::InviteTeamMemberParams
}

/// struct for passing parameters to the method [`leave_team`]
#[derive(Clone, Debug)]
pub struct LeaveTeamParams {
    /// The slug of the team to leave
    pub slug: String
}

/// struct for passing parameters to the method [`list_app_environments`]
#[derive(Clone, Debug)]
pub struct ListAppEnvironmentsParams {
    /// The name of the app to get the version for.
    pub name: String
}

/// struct for passing parameters to the method [`list_apps`]
#[derive(Clone, Debug)]
pub struct ListAppsParams {
    /// The search query to filter apps by.
    pub query: Option<String>,
    /// The page number to fetch.
    pub page: Option<i64>,
    /// The number of records to fetch on each page.
    pub page_size: Option<i64>,
    /// Time period for statistics (24h, 7d, 30d, or none)
    pub period: Option<String>,
    /// Number of recent runs to fetch (-1 for all runs, defaults to 20)
    pub num_runs: Option<i64>,
    /// Filter apps by status(es). Valid values: active, failed, disabled etc.
    pub status: Option<Vec<String>>
}

/// struct for passing parameters to the method [`list_runs`]
#[derive(Clone, Debug)]
pub struct ListRunsParams {
    /// The name of the app to fetch runs for.
    pub name: String,
    /// The page number to fetch.
    pub page: Option<i64>,
    /// The number of records to fetch on each page.
    pub page_size: Option<i64>
}

/// struct for passing parameters to the method [`list_secrets`]
#[derive(Clone, Debug)]
pub struct ListSecretsParams {
    /// The environment to filter by.
    pub environment: Option<String>,
    /// Whether to fetch all secrets or only the ones that are not marked as deleted.
    pub all: Option<bool>,
    /// The page number to fetch.
    pub page: Option<i64>,
    /// The number of records to fetch on each page.
    pub page_size: Option<i64>
}

/// struct for passing parameters to the method [`list_team_invitations`]
#[derive(Clone, Debug)]
pub struct ListTeamInvitationsParams {
    /// The slug of the team to list members for
    pub slug: String
}

/// struct for passing parameters to the method [`list_team_members`]
#[derive(Clone, Debug)]
pub struct ListTeamMembersParams {
    /// The slug of the team to list members for
    pub slug: String
}

/// struct for passing parameters to the method [`remove_team_member`]
#[derive(Clone, Debug)]
pub struct RemoveTeamMemberParams {
    /// The slug of the team to remove someone from
    pub slug: String,
    pub remove_team_member_params: models::RemoveTeamMemberParams
}

/// struct for passing parameters to the method [`resend_team_invitation`]
#[derive(Clone, Debug)]
pub struct ResendTeamInvitationParams {
    /// The slug of the team to invite someone to
    pub slug: String,
    pub resend_team_invitation_params: models::ResendTeamInvitationParams
}

/// struct for passing parameters to the method [`run_app`]
#[derive(Clone, Debug)]
pub struct RunAppParams {
    /// The name of the app to fetch runs for.
    pub name: String,
    pub run_app_params: models::RunAppParams
}

/// struct for passing parameters to the method [`stream_app_run_logs`]
#[derive(Clone, Debug)]
pub struct StreamAppRunLogsParams {
    /// The name of the app to get logs for.
    pub name: String,
    /// The sequence number of the run to get logs for.
    pub seq: i64
}

/// struct for passing parameters to the method [`update_my_team_invitation`]
#[derive(Clone, Debug)]
pub struct UpdateMyTeamInvitationParams {
    pub update_my_team_invitation_params: models::UpdateMyTeamInvitationParams
}

/// struct for passing parameters to the method [`update_team`]
#[derive(Clone, Debug)]
pub struct UpdateTeamParams {
    /// The slug of the team to update
    pub slug: String,
    pub update_team_params: models::UpdateTeamParams
}

/// struct for passing parameters to the method [`update_user`]
#[derive(Clone, Debug)]
pub struct UpdateUserParams {
    pub update_user_params: models::UpdateUserParams
}


/// struct for typed successes of method [`accept_invitation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AcceptInvitationSuccess {
    Status200(models::AcceptInvitationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`cancel_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelRunSuccess {
    Status200(models::CancelRunResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`claim_device_login_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClaimDeviceLoginTicketSuccess {
    Status200(models::ClaimDeviceLoginTicketResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAccountSuccess {
    Status200(models::CreateAccountResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApiKeySuccess {
    Status200(models::CreateApiKeyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_apps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAppsSuccess {
    Status200(models::CreateAppResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_device_login_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDeviceLoginTicketSuccess {
    Status200(models::CreateDeviceLoginTicketResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSecretSuccess {
    Status200(models::CreateSecretResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSessionSuccess {
    Status200(models::CreateSessionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`create_team`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTeamSuccess {
    Status200(models::CreateTeamResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApiKeySuccess {
    Status200(models::DeleteApiKeyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAppSuccess {
    Status200(models::DeleteAppResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSecretSuccess {
    Status204(),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_team`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTeamSuccess {
    Status200(models::DeleteTeamResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`delete_team_invitation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTeamInvitationSuccess {
    Status200(models::DeleteTeamInvitationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`deploy_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeployAppSuccess {
    Status200(models::DeployAppResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`describe_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeAppSuccess {
    Status200(models::DescribeAppResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`describe_app_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeAppVersionSuccess {
    Status200(models::DescribeAppVersionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`describe_device_login_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeDeviceLoginSessionSuccess {
    Status200(models::DescribeDeviceLoginSessionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`describe_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeRunSuccess {
    Status200(models::DescribeRunResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`describe_secrets_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeSecretsKeySuccess {
    Status200(models::DescribeSecretsKeyResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`describe_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeSessionSuccess {
    Status200(models::DescribeSessionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`export_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportSecretsSuccess {
    Status200(models::ExportSecretsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`generate_app_statistics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateAppStatisticsSuccess {
    Status200(models::GenerateAppStatisticsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`generate_run_statistics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateRunStatisticsSuccess {
    Status200(models::GenerateRunStatisticsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_app_run_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppRunLogsSuccess {
    Status200(models::GetRunLogsOutputBody),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`invite_team_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InviteTeamMemberSuccess {
    Status200(models::InviteTeamMemberResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`leave_team`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaveTeamSuccess {
    Status200(models::LeaveTeamResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_api_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListApiKeysSuccess {
    Status200(models::ListApiKeysResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_app_environments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAppEnvironmentsSuccess {
    Status200(models::ListAppEnvironmentsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_apps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAppsSuccess {
    Status200(models::ListAppsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_my_team_invitations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMyTeamInvitationsSuccess {
    Status200(models::ListMyTeamInvitationsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_runs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRunsSuccess {
    Status200(models::ListRunsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_secret_environments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSecretEnvironmentsSuccess {
    Status200(models::ListSecretEnvironmentsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSecretsSuccess {
    Status200(models::ListSecretsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_team_invitations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTeamInvitationsSuccess {
    Status200(models::ListTeamInvitationsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_team_members`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTeamMembersSuccess {
    Status200(models::ListTeamMembersResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`list_teams`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTeamsSuccess {
    Status200(models::ListTeamsResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`refresh_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RefreshSessionSuccess {
    Status200(models::RefreshSessionResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`remove_team_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveTeamMemberSuccess {
    Status200(models::RemoveTeamMemberResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`resend_team_invitation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResendTeamInvitationSuccess {
    Status200(models::ResendTeamInvitationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`run_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunAppSuccess {
    Status200(models::RunAppResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`stream_app_run_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StreamAppRunLogsSuccess {
    Status200(Vec<models::StreamAppRunLogs200ResponseInner>),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_my_team_invitation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMyTeamInvitationSuccess {
    Status200(models::UpdateMyTeamInvitationResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_team`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTeamSuccess {
    Status200(models::UpdateTeamResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`update_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserSuccess {
    Status200(models::UpdateUserResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`accept_invitation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AcceptInvitationError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelRunError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`claim_device_login_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClaimDeviceLoginTicketError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAccountError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApiKeyError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_apps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAppsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_device_login_ticket`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateDeviceLoginTicketError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSecretError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSessionError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_team`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTeamError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_api_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApiKeyError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteAppError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSecretError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_team`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTeamError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_team_invitation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTeamInvitationError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`deploy_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeployAppError {
    Status400(models::ErrorModel),
    Status422(models::ErrorModel),
    Status500(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`describe_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeAppError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`describe_app_version`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeAppVersionError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`describe_device_login_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeDeviceLoginSessionError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`describe_run`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeRunError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`describe_secrets_key`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeSecretsKeyError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`describe_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DescribeSessionError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportSecretsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_app_statistics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateAppStatisticsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`generate_run_statistics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GenerateRunStatisticsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_app_run_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAppRunLogsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`invite_team_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InviteTeamMemberError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`leave_team`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaveTeamError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_api_keys`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListApiKeysError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_app_environments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAppEnvironmentsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_apps`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAppsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_my_team_invitations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMyTeamInvitationsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_runs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRunsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_secret_environments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSecretEnvironmentsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_secrets`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSecretsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_team_invitations`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTeamInvitationsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_team_members`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTeamMembersError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_teams`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListTeamsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`refresh_session`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RefreshSessionError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_team_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveTeamMemberError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resend_team_invitation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResendTeamInvitationError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`run_app`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RunAppError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stream_app_run_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StreamAppRunLogsError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_my_team_invitation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateMyTeamInvitationError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_team`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateTeamError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserError {
    DefaultResponse(models::ErrorModel),
    UnknownValue(serde_json::Value),
}


/// Accept an invitation code to join an account
pub async fn accept_invitation(configuration: &configuration::Configuration, params: AcceptInvitationParams) -> Result<ResponseContent<AcceptInvitationSuccess>, Error<AcceptInvitationError>> {

    let uri_str = format!("{}/accounts/invite", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.accept_invitation_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<AcceptInvitationSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<AcceptInvitationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel a run
pub async fn cancel_run(configuration: &configuration::Configuration, params: CancelRunParams) -> Result<ResponseContent<CancelRunSuccess>, Error<CancelRunError>> {

    let uri_str = format!("{}/apps/{name}/runs/{seq}", configuration.base_path, name=crate::apis::urlencode(params.name), seq=params.seq);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CancelRunSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Claims a device login ticket code for the authenticated user.
pub async fn claim_device_login_ticket(configuration: &configuration::Configuration, params: ClaimDeviceLoginTicketParams) -> Result<ResponseContent<ClaimDeviceLoginTicketSuccess>, Error<ClaimDeviceLoginTicketError>> {

    let uri_str = format!("{}/login/device/claim", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.claim_device_login_ticket_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ClaimDeviceLoginTicketSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ClaimDeviceLoginTicketError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// This is the primary way that users register new accounts with Tower.
pub async fn create_account(configuration: &configuration::Configuration, params: CreateAccountParams) -> Result<ResponseContent<CreateAccountSuccess>, Error<CreateAccountError>> {

    let uri_str = format!("{}/accounts", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.create_account_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateAccountSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_api_key(configuration: &configuration::Configuration, params: CreateApiKeyParams) -> Result<ResponseContent<CreateApiKeySuccess>, Error<CreateApiKeyError>> {

    let uri_str = format!("{}/api-keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_api_key_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateApiKeySuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new app in the current account.
pub async fn create_apps(configuration: &configuration::Configuration, params: CreateAppsParams) -> Result<ResponseContent<CreateAppsSuccess>, Error<CreateAppsError>> {

    let uri_str = format!("{}/apps", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_app_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateAppsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAppsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new device login ticket and returns the codes and urls needed for authentication.
pub async fn create_device_login_ticket(configuration: &configuration::Configuration) -> Result<ResponseContent<CreateDeviceLoginTicketSuccess>, Error<CreateDeviceLoginTicketError>> {

    let uri_str = format!("{}/login/device", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateDeviceLoginTicketSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateDeviceLoginTicketError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a new secret and associates it with the current account.
pub async fn create_secret(configuration: &configuration::Configuration, params: CreateSecretParams) -> Result<ResponseContent<CreateSecretSuccess>, Error<CreateSecretError>> {

    let uri_str = format!("{}/secrets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_secret_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateSecretSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new session and return it.
pub async fn create_session(configuration: &configuration::Configuration, params: CreateSessionParams) -> Result<ResponseContent<CreateSessionSuccess>, Error<CreateSessionError>> {

    let uri_str = format!("{}/session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.create_session_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateSessionSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a new team
pub async fn create_team(configuration: &configuration::Configuration, params: CreateTeamParams) -> Result<ResponseContent<CreateTeamSuccess>, Error<CreateTeamError>> {

    let uri_str = format!("{}/teams", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.create_team_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<CreateTeamSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTeamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_api_key(configuration: &configuration::Configuration, params: DeleteApiKeyParams) -> Result<ResponseContent<DeleteApiKeySuccess>, Error<DeleteApiKeyError>> {

    let uri_str = format!("{}/api-keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_api_key_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteApiKeySuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApiKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete one of your apps, the associated code, and all the runs as well.
pub async fn delete_app(configuration: &configuration::Configuration, params: DeleteAppParams) -> Result<ResponseContent<DeleteAppSuccess>, Error<DeleteAppError>> {

    let uri_str = format!("{}/apps/{name}", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteAppSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a secret by name.
pub async fn delete_secret(configuration: &configuration::Configuration, params: DeleteSecretParams) -> Result<ResponseContent<DeleteSecretSuccess>, Error<DeleteSecretError>> {

    let uri_str = format!("{}/secrets/{name}", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.environment {
        req_builder = req_builder.query(&[("environment", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteSecretSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSecretError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a new team
pub async fn delete_team(configuration: &configuration::Configuration, params: DeleteTeamParams) -> Result<ResponseContent<DeleteTeamSuccess>, Error<DeleteTeamError>> {

    let uri_str = format!("{}/teams", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_team_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteTeamSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteTeamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a pending team invitation that you have previously sent
pub async fn delete_team_invitation(configuration: &configuration::Configuration, params: DeleteTeamInvitationParams) -> Result<ResponseContent<DeleteTeamInvitationSuccess>, Error<DeleteTeamInvitationError>> {

    let uri_str = format!("{}/teams/{slug}/invites", configuration.base_path, slug=crate::apis::urlencode(params.slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.delete_team_invitation_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeleteTeamInvitationSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteTeamInvitationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deploy a new version of an app. Reads the request body, which is a TAR file (or a GZipped TAR file) and creates a new deployment for an app based on that file.
pub async fn deploy_app(configuration: &configuration::Configuration, params: DeployAppParams) -> Result<ResponseContent<DeployAppSuccess>, Error<DeployAppError>> {

    let uri_str = format!("{}/apps/{name}/deploy", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = params.content_encoding {
        req_builder = req_builder.header("Content-Encoding", param_value.to_string());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DeployAppSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DeployAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all the runs for the current account.
pub async fn describe_app(configuration: &configuration::Configuration, params: DescribeAppParams) -> Result<ResponseContent<DescribeAppSuccess>, Error<DescribeAppError>> {

    let uri_str = format!("{}/apps/{name}", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.runs {
        req_builder = req_builder.query(&[("runs", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DescribeAppSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DescribeAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Describe an app version for an app in the current account.
pub async fn describe_app_version(configuration: &configuration::Configuration, params: DescribeAppVersionParams) -> Result<ResponseContent<DescribeAppVersionSuccess>, Error<DescribeAppVersionError>> {

    let uri_str = format!("{}/apps/{name}/versions/{num}", configuration.base_path, name=crate::apis::urlencode(params.name), num=crate::apis::urlencode(params.num));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DescribeAppVersionSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DescribeAppVersionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Checks if a device login code has been claimed and returns the user session if so.
pub async fn describe_device_login_session(configuration: &configuration::Configuration, params: DescribeDeviceLoginSessionParams) -> Result<ResponseContent<DescribeDeviceLoginSessionSuccess>, Error<DescribeDeviceLoginSessionError>> {

    let uri_str = format!("{}/login/device/{device_code}", configuration.base_path, device_code=crate::apis::urlencode(params.device_code));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DescribeDeviceLoginSessionSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DescribeDeviceLoginSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Describe a run of an app.
pub async fn describe_run(configuration: &configuration::Configuration, params: DescribeRunParams) -> Result<ResponseContent<DescribeRunSuccess>, Error<DescribeRunError>> {

    let uri_str = format!("{}/apps/{name}/runs/{seq}", configuration.base_path, name=crate::apis::urlencode(params.name), seq=params.seq);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DescribeRunSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DescribeRunError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets the encryption key used for encrypting secrets that you want to create in Tower.
pub async fn describe_secrets_key(configuration: &configuration::Configuration, params: DescribeSecretsKeyParams) -> Result<ResponseContent<DescribeSecretsKeySuccess>, Error<DescribeSecretsKeyError>> {

    let uri_str = format!("{}/secrets/key", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.format {
        req_builder = req_builder.query(&[("format", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DescribeSecretsKeySuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DescribeSecretsKeyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Validate your current session and return the user information associated with the session.
pub async fn describe_session(configuration: &configuration::Configuration) -> Result<ResponseContent<DescribeSessionSuccess>, Error<DescribeSessionError>> {

    let uri_str = format!("{}/session", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<DescribeSessionSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<DescribeSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all the secrets in your current account and re-encrypt them with the public key you supplied.
pub async fn export_secrets(configuration: &configuration::Configuration, params: ExportSecretsParams) -> Result<ResponseContent<ExportSecretsSuccess>, Error<ExportSecretsError>> {

    let uri_str = format!("{}/secrets/export", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.environment {
        req_builder = req_builder.query(&[("environment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.export_secrets_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ExportSecretsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ExportSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates current statistics about apps
pub async fn generate_app_statistics(configuration: &configuration::Configuration) -> Result<ResponseContent<GenerateAppStatisticsSuccess>, Error<GenerateAppStatisticsError>> {

    let uri_str = format!("{}/stats/apps", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GenerateAppStatisticsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateAppStatisticsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates statistics about runs over a specified time period.
pub async fn generate_run_statistics(configuration: &configuration::Configuration, params: GenerateRunStatisticsParams) -> Result<ResponseContent<GenerateRunStatisticsSuccess>, Error<GenerateRunStatisticsError>> {

    let uri_str = format!("{}/stats/runs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GenerateRunStatisticsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<GenerateRunStatisticsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves the logs associated with a particular run of an app.
pub async fn get_app_run_logs(configuration: &configuration::Configuration, params: GetAppRunLogsParams) -> Result<ResponseContent<GetAppRunLogsSuccess>, Error<GetAppRunLogsError>> {

    let uri_str = format!("{}/apps/{name}/runs/{seq}/logs", configuration.base_path, name=crate::apis::urlencode(params.name), seq=params.seq);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<GetAppRunLogsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAppRunLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Invite a new team
pub async fn invite_team_member(configuration: &configuration::Configuration, params: InviteTeamMemberParams) -> Result<ResponseContent<InviteTeamMemberSuccess>, Error<InviteTeamMemberError>> {

    let uri_str = format!("{}/teams/{slug}/invites", configuration.base_path, slug=crate::apis::urlencode(params.slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.invite_team_member_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<InviteTeamMemberSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<InviteTeamMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove yourself from a team, if that's something you'd like to do for whatever reason. If you're the last member of a team, you cannot remove yourself. You should delete the team instead.
pub async fn leave_team(configuration: &configuration::Configuration, params: LeaveTeamParams) -> Result<ResponseContent<LeaveTeamSuccess>, Error<LeaveTeamError>> {

    let uri_str = format!("{}/teams/{slug}/leave", configuration.base_path, slug=crate::apis::urlencode(params.slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<LeaveTeamSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<LeaveTeamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all the API keys associated with your current account.
pub async fn list_api_keys(configuration: &configuration::Configuration) -> Result<ResponseContent<ListApiKeysSuccess>, Error<ListApiKeysError>> {

    let uri_str = format!("{}/api-keys", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListApiKeysSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListApiKeysError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates a list of all the known environments for a given app in the current account.
pub async fn list_app_environments(configuration: &configuration::Configuration, params: ListAppEnvironmentsParams) -> Result<ResponseContent<ListAppEnvironmentsSuccess>, Error<ListAppEnvironmentsError>> {

    let uri_str = format!("{}/apps/{name}/environments", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListAppEnvironmentsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAppEnvironmentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Get all the apps for the current account.
pub async fn list_apps(configuration: &configuration::Configuration, params: ListAppsParams) -> Result<ResponseContent<ListAppsSuccess>, Error<ListAppsError>> {

    let uri_str = format!("{}/apps", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.query {
        req_builder = req_builder.query(&[("query", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.period {
        req_builder = req_builder.query(&[("period", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.num_runs {
        req_builder = req_builder.query(&[("num_runs", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.status {
        req_builder = match "csv" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("status".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("status", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListAppsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAppsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List your pending invitations for teams
pub async fn list_my_team_invitations(configuration: &configuration::Configuration) -> Result<ResponseContent<ListMyTeamInvitationsSuccess>, Error<ListMyTeamInvitationsError>> {

    let uri_str = format!("{}/team-invites", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListMyTeamInvitationsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListMyTeamInvitationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates a list of all the runs for a given app. The list is paginated based on the query string parameters passed in.
pub async fn list_runs(configuration: &configuration::Configuration, params: ListRunsParams) -> Result<ResponseContent<ListRunsSuccess>, Error<ListRunsError>> {

    let uri_str = format!("{}/apps/{name}/runs", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListRunsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListRunsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all the environments associated with secrets.
pub async fn list_secret_environments(configuration: &configuration::Configuration) -> Result<ResponseContent<ListSecretEnvironmentsSuccess>, Error<ListSecretEnvironmentsError>> {

    let uri_str = format!("{}/secrets/environments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListSecretEnvironmentsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSecretEnvironmentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists all the secrets associated with your current account.
pub async fn list_secrets(configuration: &configuration::Configuration, params: ListSecretsParams) -> Result<ResponseContent<ListSecretsSuccess>, Error<ListSecretsError>> {

    let uri_str = format!("{}/secrets", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.environment {
        req_builder = req_builder.query(&[("environment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListSecretsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSecretsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the pending invitations for a team
pub async fn list_team_invitations(configuration: &configuration::Configuration, params: ListTeamInvitationsParams) -> Result<ResponseContent<ListTeamInvitationsSuccess>, Error<ListTeamInvitationsError>> {

    let uri_str = format!("{}/teams/{slug}/invites", configuration.base_path, slug=crate::apis::urlencode(params.slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListTeamInvitationsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTeamInvitationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List the members of a team
pub async fn list_team_members(configuration: &configuration::Configuration, params: ListTeamMembersParams) -> Result<ResponseContent<ListTeamMembersSuccess>, Error<ListTeamMembersError>> {

    let uri_str = format!("{}/teams/{slug}/members", configuration.base_path, slug=crate::apis::urlencode(params.slug));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListTeamMembersSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTeamMembersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List all the teams that the user is a member of.
pub async fn list_teams(configuration: &configuration::Configuration) -> Result<ResponseContent<ListTeamsSuccess>, Error<ListTeamsError>> {

    let uri_str = format!("{}/teams", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ListTeamsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ListTeamsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a new session based on the supplied authentication context. This is helpful when clients want to use POST instead of GET to check session information.
pub async fn refresh_session(configuration: &configuration::Configuration) -> Result<ResponseContent<RefreshSessionSuccess>, Error<RefreshSessionError>> {

    let uri_str = format!("{}/session/refresh", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<RefreshSessionSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<RefreshSessionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Remove a new team
pub async fn remove_team_member(configuration: &configuration::Configuration, params: RemoveTeamMemberParams) -> Result<ResponseContent<RemoveTeamMemberSuccess>, Error<RemoveTeamMemberError>> {

    let uri_str = format!("{}/teams/{slug}/members", configuration.base_path, slug=crate::apis::urlencode(params.slug));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.remove_team_member_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<RemoveTeamMemberSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveTeamMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Resend a team invitation to a user if they need a reminder or if they lost it
pub async fn resend_team_invitation(configuration: &configuration::Configuration, params: ResendTeamInvitationParams) -> Result<ResponseContent<ResendTeamInvitationSuccess>, Error<ResendTeamInvitationError>> {

    let uri_str = format!("{}/teams/{slug}/invites/resend", configuration.base_path, slug=crate::apis::urlencode(params.slug));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.resend_team_invitation_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<ResendTeamInvitationSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<ResendTeamInvitationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Runs an app with the supplied parameters.
pub async fn run_app(configuration: &configuration::Configuration, params: RunAppParams) -> Result<ResponseContent<RunAppSuccess>, Error<RunAppError>> {

    let uri_str = format!("{}/apps/{name}/runs", configuration.base_path, name=crate::apis::urlencode(params.name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.run_app_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<RunAppSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<RunAppError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Streams the logs associated with a particular run of an app in real-time.
pub async fn stream_app_run_logs(configuration: &configuration::Configuration, params: StreamAppRunLogsParams) -> Result<ResponseContent<StreamAppRunLogsSuccess>, Error<StreamAppRunLogsError>> {

    let uri_str = format!("{}/apps/{name}/runs/{seq}/logs/stream", configuration.base_path, name=crate::apis::urlencode(params.name), seq=params.seq);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<StreamAppRunLogsSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<StreamAppRunLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a team invitation that you have pending
pub async fn update_my_team_invitation(configuration: &configuration::Configuration, params: UpdateMyTeamInvitationParams) -> Result<ResponseContent<UpdateMyTeamInvitationSuccess>, Error<UpdateMyTeamInvitationError>> {

    let uri_str = format!("{}/team-invites", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.update_my_team_invitation_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<UpdateMyTeamInvitationSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateMyTeamInvitationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a team with a new name or slug. Note that updating the team with a new slug will cause all your URLs to change!
pub async fn update_team(configuration: &configuration::Configuration, params: UpdateTeamParams) -> Result<ResponseContent<UpdateTeamSuccess>, Error<UpdateTeamError>> {

    let uri_str = format!("{}/teams/{slug}", configuration.base_path, slug=crate::apis::urlencode(params.slug));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.update_team_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<UpdateTeamSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateTeamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates your current user profile.
pub async fn update_user(configuration: &configuration::Configuration, params: UpdateUserParams) -> Result<ResponseContent<UpdateUserSuccess>, Error<UpdateUserError>> {

    let uri_str = format!("{}/user", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&params.update_user_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        let entity: Option<UpdateUserSuccess> = serde_json::from_str(&content).ok();
        Ok(ResponseContent { status, content, entity })
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

